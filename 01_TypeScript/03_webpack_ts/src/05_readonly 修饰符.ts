/**
 * readonly
 *
 * 将属性设置为只读。只读属性必须在声明时或构造函数里被初始化
 * 关键字，对类中的属性成员进行修饰，修饰后，该成员属性就不能在外部被随意的修改了
 *
 * 如果构造函数中没有任何的参数，类中的属性成员此时已经使用readonly进行修饰了，
 * 那么外部也是不能对这个属性值进行更改的
 * 
 * 构造函数中，可以对只读的属性成员的数据进行修改
 * 如果构造函数中没有任何参数，类中的属性成员此时已经使用 readonly 进行修饰，那么外部也是不能对这个属性值进行更改的
 * 
 * 构造函数中的参数，一旦使用了 readonly  进行修饰，那么该参数可以交 属性参数
 * 构造函数中的参数，一旦使用了 readonly  进行修饰，那么类中就有可能一个该参数的属性成员
 * 构造函数中的参数，一旦使用了 readonly  进行修饰，外部也是无法修改类中该属性成员的值
 * 构造函数中的参数，一旦使用了 public    进行修饰，那么该类中就有了一个公共的该属性成员
 * 构造函数中的参数，一旦使用了 private   进行修饰，那么该类中就有了一个私有的该属性成员
 * 构造函数中的参数，一旦使用了 protected 进行修饰，那么该类中就有了一个受保护的该属性成员（只能在本类和派生类中访问及使用）
 * 
 * 构造函数中的参数可以使用 readonly 进行修饰，一旦修饰，那么该类中就有了这个只读的成员属性了，外部可以访问，但是不能修改
 * 构造函数中的参数可以使用 public及private和protected进行修饰，无论哪个进行修饰，那么该类中都会自动添加这么一个属性成员
 * 
 * 
 */

(() => {
	// 定义一个类型
	class Person {
		// 属性
		readonly name: string;
		constructor(name: string) {
			this.name = name;
		}
		sayHi() {
			console.log("库尼奇瓦", this.name);
			// 类中的普通方法中，也不能修改 readonly 修饰的成员属性值
			// this.name = "老王";
		}
	}
	// 实例化对象
	const person = new Person("小李");
	console.log(person);
	console.log(person.name);
	// person.name = "小王"; // 此时无法修改，变成只读属性，无法修改
	console.log(person.name);
})();
